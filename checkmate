#!/usr/bin/env python3
import logging
import sys
from argparse import ArgumentParser
import json
from enum import Enum

from analysis import analyze_input
from checkmatecheck import check_joint_strategies
from constants import SecurityProperty, ANALYSIS_JSON_KEY
from input import Input


class Subcommand(Enum):
    ANALYZE = 'analyze'
    CHECK = 'check'


if __name__ == '__main__':
    # set signal handler to OS default so that console interrupts behave as expected
    # this is usually "terminate reasonably rapidly" for SIGINT
    # Python's default is "wait around for any native code, then consider KeyboardInterrupt on a good day"
    from signal import SIGINT, SIG_DFL, signal

    signal(SIGINT, SIG_DFL)

    security_properties = [member.value for member in SecurityProperty]

    logging.basicConfig(
        level=logging.INFO,
        format='[%(levelname)s] %(message)s'
    )

    parser = ArgumentParser(
        description="check game-theoretic security properties of off-chain protocols"
    )
    parser.add_argument(
        'GAME',
        type=str,
        help="path to JSON encoding of input game"
    )

    subparsers = parser.add_subparsers(title='subcommands',
                                       description='specify whether CheckMate should analyze the input game or '
                                                   'check existing joint strategies',
                                       dest='subcommand')

    analyze_parser = subparsers.add_parser(Subcommand.ANALYZE.value, help='security analysis of input game')
    check_parser = subparsers.add_parser(Subcommand.CHECK.value,
                                         help='check if provided strategies truly satisfy security properties')

    generation = analyze_parser.add_mutually_exclusive_group()
    analyze_parser.add_argument(
        '--properties',
        nargs='+',
        choices=security_properties,
        default=security_properties,
        help='specify analyzed security properties',
    )
    analyze_parser.add_argument(
        '--output',
        action='store_true',
        help="print strategies as JSON to standard output"
    )
    generation.add_argument(
        '--preconditions',
        action='store_true',
        help="generate preconditions if a case fails"
    )
    generation.add_argument(
        '--counterexamples',
        action='store_true',
        help="generate counterexamples if a case fails"
    )

    check_parser.add_argument(
        'STRATEGIES',
        type=str,
        help="path to JSON encoding of joint strategies to check"
    )

    args = parser.parse_args()
    checked_input = Input(args.GAME)

    if args.subcommand == Subcommand.ANALYZE.value:
        analyzed_properties = [sec_prop for sec_prop in SecurityProperty if sec_prop.value in args.properties]
        results = analyze_input(checked_input, analyzed_properties, args.preconditions, args.counterexamples)

        if args.output:
            result_jsons = [result.to_json() for result in results]
            json.dump({ANALYSIS_JSON_KEY: result_jsons}, fp=sys.stdout, indent=4)

    elif args.subcommand == Subcommand.CHECK.value:
        check_joint_strategies(checked_input, json.load(open(args.STRATEGIES)))

    else:
        parser.print_usage()
