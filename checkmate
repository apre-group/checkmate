#!/usr/bin/env python3

from argparse import ArgumentParser
import json
import logging
import sys

from constants import ANALYSIS_JSON_KEY, SecurityProperty, PROPERTY_TO_STR
from output import AnalysisResult
from solving import WeakImmunityStrategySolver, WeakerImmunityStrategySolver, CollusionResilienceStrategySolver, \
    PracticalityStrategySolver
from input import Input

if __name__ == '__main__':
    # set signal handler to OS default so that console interrupts behave as expected
    # this is usually "terminate reasonably rapidly" for SIGINT
    # Python's default is "wait around for any native code, then consider KeyboardInterrupt on a good day"
    from signal import SIGINT, SIG_DFL, signal

    signal(SIGINT, SIG_DFL)

    security_properties = [member.value for member in SecurityProperty]

    logging.basicConfig(
        level=logging.INFO,
        format='[%(levelname)s] %(message)s'
    )
    parser = ArgumentParser(
        description="check game-theoretic security properties of off-chain protocols"
    )
    parser.add_argument(
        'PATH',
        type=str,
        help="path to input JSON"
    )
    parser.add_argument(
        '--analyze-properties',
        nargs='+',
        choices=security_properties,
        default=security_properties,
        help='specify analyzed security properties',
    )
    parser.add_argument(
        '--output-strategies',
        action='store_true',
        help="print strategies as JSON to standard output"
    )
    parser.add_argument(
        '--generate-preconditions',
        action='store_true',
        help="generate preconditions if a case fails"
    )
    parser.add_argument(
        '--generate-counterexamples',
        action='store_true',
        help="generate counterexamples if a case fails"
    )
    args = parser.parse_args()
    analyzed_properties_str = args.analyze_properties
    output = args.output_strategies
    generate_preconditions = args.generate_preconditions
    generate_counterexamples = args.generate_counterexamples
    if generate_preconditions and generate_counterexamples:
        raise Exception("Generating preconditions and counterexamples at the same time is not supported.")
    checked_input = Input(args.PATH)
    logging.info(
        f"input OK, checking {len(checked_input.honest_histories)} histories..."
    )

    analyzed_properties = [sec_prop for sec_prop in SecurityProperty if sec_prop.value in analyzed_properties_str]
    results = []
    for honest_history in checked_input.honest_histories:
        wi_res, weri_res, cr_res, p_res = None, None, None, None
        logging.info(f"history {honest_history}")

        if SecurityProperty.WEAK_IMMUNITY in analyzed_properties:
            logging.info("checking weak immunity")
            wi_res = WeakImmunityStrategySolver(
                checked_input,
                honest_history,
                generate_preconditions,
                generate_counterexamples
            ).solve()

        if SecurityProperty.WEAKER_IMMUNITY in analyzed_properties:
            logging.info("checking weaker immunity")
            weri_res = WeakerImmunityStrategySolver(
                checked_input,
                honest_history,
                generate_preconditions,
                generate_counterexamples
            ).solve()

        if SecurityProperty.COLLUSION_RESILIENCE in analyzed_properties:
            logging.info("checking collusion resilience")
            cr_res = CollusionResilienceStrategySolver(
                checked_input,
                honest_history,
                generate_preconditions,
                generate_counterexamples
            ).solve()

        if SecurityProperty.PRACTICALITY in analyzed_properties:
            logging.info("checking practicality")
            p_res = PracticalityStrategySolver(
                checked_input,
                honest_history,
                generate_preconditions,
                generate_counterexamples
            ).solve()

        results.append(AnalysisResult(honest_history, wi_res, weri_res, cr_res, p_res))

    # nice summary of the check
    logging.info("####### Summary: ######")
    for result in results:
        logging.info(f"Honest history {result.honest_history}")

        for security_property in analyzed_properties:
            property_result = result.get_property_result(security_property)
            found_strategies = property_result.strategies
            gen_preconditions = property_result.generated_preconditions

            if not found_strategies:
                logging.info(f"-- doesn't have {PROPERTY_TO_STR[security_property]}")

            elif len(found_strategies) == 1:
                logging.info(
                    f"-- has {PROPERTY_TO_STR[security_property]} (one strategy)" if not gen_preconditions
                    else f"-- has {PROPERTY_TO_STR[security_property]} if {gen_preconditions} (one strategy)"
                )

            else:
                logging.info(
                    f"-- has {PROPERTY_TO_STR[security_property]} "
                    f"with different strategies for cases" if not gen_preconditions
                    else f"-- has {PROPERTY_TO_STR[security_property]} if {gen_preconditions} "
                         f"with different strategies for cases"
                )

                for i, cws in enumerate(found_strategies):
                    logging.info(f"---- case {i}: {[str(c) for c in cws.ordering_case]}")

    if output:
        result_jsons = [result.to_json() for result in results]
        json.dump({ANALYSIS_JSON_KEY: result_jsons}, fp=sys.stdout, indent=4)
