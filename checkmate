#!/usr/bin/env python3

# allow type annotations for the current class
# minimum version: 3.7, will be default in future
from __future__ import annotations

from abc import ABCMeta, abstractmethod
from argparse import ArgumentParser
import itertools
import json
import logging
import sys
from typing import Any, Dict, List, Set, Tuple
import z3

from auxfunz3 import Real, Boolean, negation, conjunction, disjunction, implication
from utility import Utility, ZERO
from trees import Tree, Leaf, Branch, Input


class StrategySolver(metaclass=ABCMeta):
    """
    base class for generating strategies from constraints

    subclasses override a few functions and use provided methods
    to implement e.g. weak immunity
    """
    input: Input
    _solver: z3.Solver
    _pair2label: Dict[Tuple[Real, Real], z3.FuncDeclRef]
    # note extra boolean to partition comparisons into real/infinitesimal
    _label2pair: Dict[z3.FuncDeclRef, Tuple[Real, Real, bool]]
    _action_variables: Dict[z3.FuncDeclRef, Tuple[List[str], str]]
    _utility_variables: Set[Real]

    @abstractmethod
    def _property_initial_constraints(self) -> List[Boolean]:
        pass

    @abstractmethod
    def _property_constraint_impl(self) -> Boolean:
        pass

    def __init__(self, input: Input, checked_history: List[str]):
        """create a solver for a certain input and checked history"""
        self.input = input
        self.checked_history = checked_history
        self._solver = z3.Solver()
        self._solver.set("unsat_core", True)
        self._solver.set("core.minimize", True)
        # maintain a bijection from (left, right) expression pairs and Z3 labels
        self._pair2label = {}
        self._label2pair = {}
        # mapping from action variables to (history, action) pairs
        self._action_variables = {}
        # the set of utility variables so that we exclude them from case splits
        self._utility_variables = set()

        self._add_action_constraints([], input.tree)
        self._add_history_constraints(self.checked_history)

    def solve(self, output: bool) -> List[Dict[str, Any]]:
        """
        the main solving routine

        if `not output` or we failed to find a solution, return empty list
        otherwise, returns a solution to report later
        """

        result = []
        # a solver that manages case splits, AVATAR style
        case_solver = z3.Solver()
        # it should know about initial constraints for the property we're trying
        for constraint in itertools.chain(
                self.input.initial_constraints,
                self._property_initial_constraints()
        ):
            case_solver.add(constraint)

        # there is no point in comparing e.g. p_A > epsilon
        # therefore, partition case splits into real and infinitesimal parts
        reals = set()
        infinitesimals = set()

        while case_solver.check() == z3.sat:
            # an assignment of variables to concrete real values
            model = case_solver.model()

            # we can use this model to decide whether
            # left > right, left = right or left < right
            def split(left, right):
                if model.evaluate(left > right, True):
                    return left > right
                elif model.evaluate(left == right, True):
                    return left == right
                else:
                    return right > left

            # the current case is the conjunction of all known expression comparisons
            case = [
                split(left, right)
                for left, right in itertools.chain(
                    itertools.combinations(reals, 2),
                    itertools.combinations(infinitesimals, 2)
                )
                # no point in providing e.g. 2.0 > 1.0
                if type(left) != float or type(right) != float
            ]
            logging.info(f"current case assumes {case}")

            if self._solver.check(self._property_constraint(case)) == z3.sat:
                logging.info("case solved")
                if output:
                    result.append(self._extract_strategy(case))

                # we solved this case, now add a conflict to move on
                case_solver.add(disjunction(*(
                    negation(spl) for spl in case
                )))
            else:
                # we need to compare more expressions
                logging.info("no solution, trying case split")

                # track whether we actually found any more
                new_expression = False
                for item in self._solver.unsat_core():
                    # sometimes solver generates garbage for some reason, exclude it
                    if isinstance(item, z3.BoolRef) and z3.is_app(item):
                        label = item.decl()

                        if label in self._label2pair:
                            # `left op right` was in an unsat core
                            left, right, real = self._label2pair[label]
                            # partition reals/infinitesimals
                            add_to = reals if real else infinitesimals

                            for x in (left, right):
                                # exclude utility variables
                                if x in self._utility_variables:
                                    continue
                                # found one we didn't know about yet
                                if x not in add_to:
                                    logging.info(f"new expression: {x}")
                                    add_to.add(x)
                                    new_expression = True

                # we saturated, give up
                if not new_expression:
                    logging.error("no more splits, failed")
                    return []

        # there are no more possible models, i.e. no more cases to be discharged
        logging.info("no more cases, done")
        return result

    def _add_action_constraints(self, history: List[str], tree: Tree):
        """exactly one action must be taken at this subtree"""
        if isinstance(tree, Leaf):
            return

        assert isinstance(tree, Branch)
        actions = [
            self._action_variable(history, action)
            for action in tree.actions
        ]
        self._solver.add(disjunction(*actions))
        for (left, right) in itertools.combinations(actions, 2):
            self._solver.add(disjunction(negation(left), negation(right)))

        for action, tree in tree.actions.items():
            self._add_action_constraints(history + [action], tree)

    def _add_history_constraints(self, checked_history: List[str]):
        """we only care about this history"""
        for i in range(len(checked_history)):
            self._solver.add(self._action_variable(
                checked_history[:i], checked_history[i]
            ))

    def _define_utility_variable(
            self,
            constraints: List[z3.BoolRef],
            starting_from: List[str],
            player: str,
            tree: Tree
    ) -> Utility:
        """
        define a utility variable for a player starting at a subtree

        a new variable is registered and constraints are added to `constraints`
        """
        variable = self._utility_variable(starting_from, player)
        self._add_utility_constraints(
            constraints,
            variable,
            player,
            starting_from,
            [],
            tree
        )
        return variable

    def _add_utility_constraints(
            self,
            constraints: List[z3.BoolRef],
            variable: Utility,
            player: str,
            history: List[str],
            decisions: List[z3.BoolRef],
            tree: Tree
    ):
        """add constraints to give the semantics of a utility variable"""
        if isinstance(tree, Leaf):
            utility = tree.utilities[player]
            # if we take `decisions` to a leaf, the utility variable has a known value
            constraints.append(implication(
                conjunction(*decisions),
                Utility.__eq__(variable, utility, self._label)
            ))
            return

        assert isinstance(tree, Branch)
        for action, child in tree.actions.items():
            self._add_utility_constraints(
                constraints,
                variable,
                player,
                history + [action],
                decisions + [self._action_variable(history, action)],
                child
            )

    def _property_constraint(self, case: List[Boolean]) -> z3.BoolRef:
        """
        create a universally-quantified constraint for a given property of the form
        ```
        forall <input constants>.
            <initial constraints> &&
            self._property_initial_constraints() &&
            <case split> => self._property_constraint_impl()
        ```
        """
        constraint = self._property_constraint_impl()
        return self._quantify_constants(implication(
            conjunction(
                *self.input.initial_constraints,
                *self._property_initial_constraints(),
                *case
            ),
            constraint
        ))

    def _quantify_constants(self, constraint: z3.BoolRef) -> z3.BoolRef:
        """quantify `constraint` with the input constants"""
        if len(self.input.constants) == 0:
            return constraint

        return z3.ForAll(
            [z3.Real(constant) for constant in self.input.constants],
            constraint
        )

    def _action_variable(self, history: List[str], action: str) -> z3.BoolRef:
        """the variable representing taking `action` after `history`"""
        tag = ';'.join(history)
        func = z3.Function(f'a[{tag}][{action}]', z3.BoolSort())
        self._action_variables[func] = (history, action)
        return func()

    def _utility_variable(self, starting_from: List[str], player: str) -> Utility:
        """create real/infinitesimal variables to represent a utility"""
        tag = ''.join(starting_from)
        utility = Utility(
            z3.Real(f'ur[{tag}][{player}]'),
            z3.Real(f'ui[{tag}][{player}]')
        )
        self._utility_variables.update((utility.real, utility.inf))
        return utility

    def _label(
            self,
            left: Real,
            right: Real,
            real: bool
    ) -> z3.BoolRef:
        """label comparisons for unsat cores"""
        label = self._pair2label.get((left, right))
        if label is None:
            label = z3.Function(f'l[{left}][{right}]', z3.BoolSort())
            self._pair2label[(left, right)] = label
            # store whether the comparison is real-valued for partition later
            self._label2pair[label] = (left, right, real)
            # also assert them here
            expr = label()
            self._solver.assert_and_track(expr, expr)
        else:
            expr = label()

        return expr

    def _extract_strategy(self, case: List[z3.BoolRef]) -> Dict[str, Any]:
        strategy = {}
        model = self._solver.model()
        for name in model:
            if name not in self._label2pair and model[name]:
                history, action = self._action_variables[name]
                strategy[';'.join(history)] = action

        return {
            "case": [repr(c) for c in case],
            "strategy": strategy
        }


class WeakImmuneStrategySolver(StrategySolver):
    """solver for weak immunity"""

    def _property_initial_constraints(self) -> List[Boolean]:
        return self.input.weak_immunity_constraints

    def _property_constraint_impl(self) -> z3.BoolRef:
        constraints = []
        for player in self.input.players:
            self._collect_weak_immunity_constraints(
                constraints, player, [], [], self.input.tree
            )
        return conjunction(*constraints)

    def _collect_weak_immunity_constraints(
            self,
            constraints: List[z3.BoolRef],
            player: str,
            player_decisions: List[z3.BoolRef],
            history: List[str],
            tree: Tree
    ):
        if isinstance(tree, Leaf):
            constraints.append(implication(
                conjunction(*player_decisions),
                Utility.__ge__(tree.utilities[player], ZERO, self._label)
            ))
            return

        assert isinstance(tree, Branch)
        player_decision = tree.player == player
        for action, child in tree.actions.items():
            action_variable = [self._action_variable(history, action)] \
                if player_decision \
                else []
            self._collect_weak_immunity_constraints(
                constraints,
                player,
                player_decisions + action_variable,
                history + [action],
                child
            )


class CollusionResilienceStrategySolver(StrategySolver):
    """solver for collusion resilience"""

    def _property_initial_constraints(self) -> List[Boolean]:
        return self.input.collusion_resilience_constraints

    def _property_constraint_impl(self) -> z3.BoolRef:
        utilities_of_checked_history = self.input.tree.get_utility_of_terminal_history(self.checked_history)

        constraints = []
        for group_size in range(1, len(self.input.players)):
            for colluding_group in itertools.combinations(self.input.players, group_size):
                old_utility = sum((
                    utilities_of_checked_history[player]
                    for player in colluding_group
                ), start=ZERO)
                self._collect_collusion_resilience_constraints(
                    constraints,
                    old_utility,
                    colluding_group,
                    [],
                    [],
                    self.input.tree
                )

        return conjunction(*constraints)

    def _collect_collusion_resilience_constraints(
            self,
            constraints: List[z3.BoolRef],
            old_utility: Utility,
            colluding_group: Tuple[str],
            nongroup_decisions: List[z3.BoolRef],
            history: List[str],
            tree: Tree
    ):
        if isinstance(tree, Leaf):
            colluding_utility = sum((
                tree.utilities[player]
                for player in colluding_group
            ), start=ZERO)
            constraints.append(implication(
                conjunction(*nongroup_decisions),
                Utility.__ge__(old_utility, colluding_utility, self._label)
            ))
            return

        assert isinstance(tree, Branch)
        group_decision = tree.player in colluding_group
        for action, child in tree.actions.items():
            action_variable = [] \
                if group_decision \
                else [self._action_variable(history, action)]
            self._collect_collusion_resilience_constraints(
                constraints,
                old_utility,
                colluding_group,
                nongroup_decisions + action_variable,
                history + [action],
                child
            )


class PracticalityStrategySolver(StrategySolver):
    """solver for practicality"""

    def _property_initial_constraints(self) -> List[Boolean]:
        return self.input.practicality_constraints

    def _property_constraint_impl(self) -> z3.BoolRef:
        constraints = []
        self._practicality_constraints(constraints, [], self.input.tree)
        return conjunction(*constraints)

    def _practicality_constraints(
            self,
            constraints: List[z3.BoolRef],
            history: List[str],
            tree: Tree
    ):
        if isinstance(tree, Leaf):
            return

        assert isinstance(tree, Branch)
        utility_constraints = []
        utility_variables = {
            player: self._define_utility_variable(
                utility_constraints,
                history,
                player,
                tree
            )
            for player in input.players
        }

        nash_constraints = []
        for player in self.input.players:
            self._nash_constraints(
                nash_constraints,
                utility_variables[player],
                player,
                history,
                [],
                tree
            )

        constraints.append(z3.ForAll(
            [
                var
                for value in utility_variables.values()
                for var in (value.real, value.inf)
            ],
            implication(
                conjunction(*utility_constraints),
                conjunction(*nash_constraints)
            )
        ))

        for action, child in tree.actions.items():
            self._practicality_constraints(
                constraints,
                history + [action],
                child
            )

    def _nash_constraints(
            self,
            constraints: List[z3.BoolRef],
            old_utility: Utility,
            player: str,
            history: List[str],
            nonplayer_decisions: List[z3.BoolRef],
            tree: Tree
    ):
        if isinstance(tree, Leaf):
            deviating_utility = tree.utilities[player]
            constraints.append(implication(
                conjunction(*nonplayer_decisions),
                Utility.__ge__(old_utility, deviating_utility, self._label)
            ))
            return

        assert isinstance(tree, Branch)
        player_decision = player == tree.player
        for action, child in tree.actions.items():
            action_variable = [] \
                if player_decision \
                else [self._action_variable(history, action)]
            self._nash_constraints(
                constraints,
                old_utility,
                player,
                history + [action],
                nonplayer_decisions + action_variable,
                child
            )


if __name__ == '__main__':
    logging.basicConfig(
        level=logging.INFO,
        format='[%(levelname)s] %(message)s'
    )
    parser = ArgumentParser(
        description="check game-theoretic security properties of off-chain protocols"
    )
    parser.add_argument(
        'PATH',
        type=str,
        help="path to input file"
    )
    parser.add_argument(
        '--output-strategies',
        action='store_true',
        help="print strategies as JSON"
    )
    args = parser.parse_args()
    output = args.output_strategies
    input = Input(args.PATH)
    logging.info(
        f"input OK, checking {len(input.honest_histories)} histories..."
    )

    strategies = []
    for honest_history in input.honest_histories:
        result: Dict[str, Any] = {"history": honest_history}
        logging.info(f"history {honest_history}")

        logging.info("checking weak immunity")
        result["weak_immunity"] = WeakImmuneStrategySolver(
            input,
            honest_history
        ).solve(output)

        logging.info("checking collusion resilience")
        result["collusion_resilience"] = CollusionResilienceStrategySolver(
            input,
            honest_history
        ).solve(output)

        logging.info("checking practicality")
        result["practicality"] = PracticalityStrategySolver(
            input,
            honest_history
        ).solve(output)

        strategies.append(result)

    if output:
        json.dump({"strategies": strategies}, fp=sys.stdout, indent=4)
